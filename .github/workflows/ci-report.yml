name: CI Report

on:
  workflow_run:
    workflows: ["CI", "Formatting", "Linting"]
    types:
      - completed

jobs:
  report:
    name: Report CI Results
    runs-on: ubuntu-latest
    if: github.event.workflow_run.event == 'pull_request'
    permissions:
      contents: read
      pull-requests: write
      actions: read
      checks: write
      statuses: write
    defaults:
      run:
        shell: bash
    steps:
      # Download artifacts based on which workflow triggered this run
      - name: Download test reports (CI workflow only)
        if: github.event.workflow_run.name == 'CI'
        uses: actions/download-artifact@v7
        continue-on-error: true
        with:
          run-id: ${{ github.event.workflow_run.id }}
          github-token: ${{ github.token }}
          path: reports/
          pattern: test-reports-*
          merge-multiple: true

      - name: Download coverage reports (CI workflow only)
        if: github.event.workflow_run.name == 'CI'
        uses: actions/download-artifact@v7
        continue-on-error: true
        with:
          run-id: ${{ github.event.workflow_run.id }}
          github-token: ${{ github.token }}
          path: coverage-reports/
          pattern: coverage-reports
          merge-multiple: true

      - name: Download formatting results (Formatting workflow only)
        if: github.event.workflow_run.name == 'Formatting'
        uses: actions/download-artifact@v7
        continue-on-error: true
        with:
          run-id: ${{ github.event.workflow_run.id }}
          github-token: ${{ github.token }}
          path: formatting-results/
          pattern: formatting-results
          merge-multiple: true

      - name: Download linting results (Linting workflow only)
        if: github.event.workflow_run.name == 'Linting'
        uses: actions/download-artifact@v7
        continue-on-error: true
        with:
          run-id: ${{ github.event.workflow_run.id }}
          github-token: ${{ github.token }}
          path: linting-results/
          pattern: linting-results
          merge-multiple: true

      # Get PR number from workflow run
      - name: Get PR information
        id: pr-info
        uses: actions/github-script@v8
        with:
          script: |
            // Get the PR number from the workflow run
            const workflowRun = context.payload.workflow_run;
            const pullRequests = workflowRun.pull_requests;

            if (!pullRequests || pullRequests.length === 0) {
              console.log('No pull requests found for this workflow run');
              return { prNumber: null };
            }

            const prNumber = pullRequests[0].number;
            console.log(`Found PR #${prNumber}`);

            // Get the workflow run conclusion
            const conclusion = workflowRun.conclusion;
            const success = conclusion === 'success';

            return {
              prNumber,
              success,
              conclusion,
              headSha: workflowRun.head_sha,
              workflowName: workflowRun.name
            };

      # Create/update PR comment with results
      - name: Create test summary comment
        if: steps.pr-info.outputs.result && fromJSON(steps.pr-info.outputs.result).prNumber
        uses: actions/github-script@v8
        with:
          script: |
            const fs = require('fs');
            const path = require('path');

            const prNumber = ${{ fromJSON(steps.pr-info.outputs.result).prNumber }};
            const workflowSuccess = ${{ fromJSON(steps.pr-info.outputs.result).success }};
            const headSha = '${{ fromJSON(steps.pr-info.outputs.result).headSha }}';
            const workflowName = '${{ fromJSON(steps.pr-info.outputs.result).workflowName }}';

            const COMMENT_IDENTIFIER = '<!-- ci-report-comment -->';

            // Function to parse JUnit XML
            function parseJUnit(xmlContent) {
              let testMatch = xmlContent.match(/<testsuite[^>]*tests="(\d+)"[^>]*errors="(\d+)"[^>]*failures="(\d+)"/);

              if (!testMatch) {
                const testsMatch = xmlContent.match(/tests="(\d+)"/);
                const errorsMatch = xmlContent.match(/errors="(\d+)"/);
                const failuresMatch = xmlContent.match(/failures="(\d+)"/);

                if (testsMatch) {
                  const tests = parseInt(testsMatch[1]);
                  const errors = errorsMatch ? parseInt(errorsMatch[1]) : 0;
                  const failures = failuresMatch ? parseInt(failuresMatch[1]) : 0;
                  return {
                    total: tests,
                    errors: errors,
                    failures: failures,
                    passed: tests - errors - failures
                  };
                }
              }

              if (!testMatch) {
                const testcases = (xmlContent.match(/<testcase/g) || []).length;
                const failures = (xmlContent.match(/<failure/g) || []).length;
                const errors = (xmlContent.match(/<error/g) || []).length;

                if (testcases > 0) {
                  return {
                    total: testcases,
                    errors: errors,
                    failures: failures,
                    passed: testcases - errors - failures
                  };
                }
              }

              if (testMatch) {
                return {
                  total: parseInt(testMatch[1]),
                  errors: parseInt(testMatch[2]),
                  failures: parseInt(testMatch[3]),
                  passed: parseInt(testMatch[1]) - parseInt(testMatch[2]) - parseInt(testMatch[3])
                };
              }

              return { total: 0, errors: 0, failures: 0, passed: 0 };
            }

            // Parse LCOV coverage
            function parseLCOVCoverage(filePath) {
              try {
                if (!fs.existsSync(filePath)) {
                  return 'No coverage';
                }

                const lcovContent = fs.readFileSync(filePath, 'utf8');
                let totalLines = 0;
                let hitLines = 0;

                const lines = lcovContent.split('\n');
                for (const line of lines) {
                  if (line.startsWith('DA:')) {
                    totalLines++;
                    const hitCount = parseInt(line.split(',')[1] || '0');
                    if (hitCount > 0) {
                      hitLines++;
                    }
                  }
                }

                if (totalLines === 0) {
                  return 'No data';
                }

                const percentage = Math.round((hitLines / totalLines) * 100);
                return `${percentage}% (${hitLines}/${totalLines})`;
              } catch (error) {
                return 'Parse error';
              }
            }

            // Parse existing comment to preserve data from other workflows
            async function getExistingData() {
              try {
                const comments = await github.rest.issues.listComments({
                  owner: context.repo.owner,
                  repo: context.repo.repo,
                  issue_number: prNumber,
                });

                const existingComment = comments.data.find(comment =>
                  comment.user.type === 'Bot' &&
                  comment.body.includes(COMMENT_IDENTIFIER)
                );

                if (existingComment) {
                  // Parse existing data from comment
                  const body = existingComment.body;
                  const data = {
                    commentId: existingComment.id,
                    formatting: null,
                    linting: null,
                    tests: null
                  };

                  // Extract formatting section
                  const fmtMatch = body.match(/<!-- formatting-data: (.*?) -->/);
                  if (fmtMatch) data.formatting = JSON.parse(fmtMatch[1]);

                  // Extract linting section
                  const lintMatch = body.match(/<!-- linting-data: (.*?) -->/);
                  if (lintMatch) data.linting = JSON.parse(lintMatch[1]);

                  // Extract tests section
                  const testsMatch = body.match(/<!-- tests-data: (.*?) -->/);
                  if (testsMatch) data.tests = JSON.parse(testsMatch[1]);

                  return data;
                }
              } catch (error) {
                console.log('Could not get existing comment:', error.message);
              }
              return { commentId: null, formatting: null, linting: null, tests: null };
            }

            // Get existing data
            const existingData = await getExistingData();

            // Process current workflow results
            let formattingData = existingData.formatting;
            let lintingData = existingData.linting;
            let testsData = existingData.tests;

            if (workflowName === 'Formatting') {
              try {
                const resultsPath = 'formatting-results/results.json';
                if (fs.existsSync(resultsPath)) {
                  const content = fs.readFileSync(resultsPath, 'utf8');
                  const results = JSON.parse(content);
                  formattingData = {
                    rust_fmt: results.rust_fmt,
                    prettier_fmt: results.prettier_fmt,
                    success: results.rust_fmt === 'success' && results.prettier_fmt === 'success'
                  };
                }
              } catch (error) {
                console.log('Could not read formatting results:', error.message);
              }
            }

            if (workflowName === 'Linting') {
              try {
                const resultsPath = 'linting-results/results.json';
                if (fs.existsSync(resultsPath)) {
                  const content = fs.readFileSync(resultsPath, 'utf8');
                  const results = JSON.parse(content);
                  lintingData = {
                    rust_lint: results.rust_lint,
                    eslint: results.eslint,
                    success: results.rust_lint === 'success' && results.eslint === 'success'
                  };
                }
              } catch (error) {
                console.log('Could not read linting results:', error.message);
              }
            }

            if (workflowName === 'CI') {
              // Process test results
              const results = {};
              const runtimes = ['deno', 'bun', 'node', 'cargo'];

              for (const runtime of runtimes) {
                results[runtime] = { total: 0, passed: 0, failures: 0, errors: 0 };
              }

              const reportsPath = 'reports';
              if (fs.existsSync(reportsPath)) {
                const files = fs.readdirSync(reportsPath);
                for (const file of files) {
                  if (file.endsWith('.xml')) {
                    const content = fs.readFileSync(path.join(reportsPath, file), 'utf8');
                    const parsed = parseJUnit(content);

                    let runtime = null;
                    if (file.includes('deno')) runtime = 'deno';
                    else if (file.includes('bun')) runtime = 'bun';
                    else if (file.includes('node')) runtime = 'node';
                    else if (file.includes('cargo')) runtime = 'cargo';

                    if (runtime && parsed.total > 0) {
                      results[runtime] = parsed;
                    }
                  }
                }
              }

              testsData = {
                results,
                denoCoverage: parseLCOVCoverage('coverage-reports/deno-lcov.info'),
                bunCoverage: parseLCOVCoverage('coverage-reports/bun-lcov.info'),
                nodeCoverage: parseLCOVCoverage('coverage-reports/node-lcov.info'),
                rustCoverage: parseLCOVCoverage('coverage-reports/rust.lcov'),
                success: workflowSuccess
              };
            }

            // Build the comment
            let summary = `${COMMENT_IDENTIFIER}\n## üß™ CI Results\n\n`;

            // Formatting section
            summary += `### Formatting\n`;
            if (formattingData) {
              const rustFmtStatus = formattingData.rust_fmt === 'success' ? '‚úÖ' : '‚ùå';
              const prettierStatus = formattingData.prettier_fmt === 'success' ? '‚úÖ' : '‚ùå';
              summary += `| Check | Status |\n`;
              summary += `|-------|--------|\n`;
              summary += `| Rust fmt | ${rustFmtStatus} |\n`;
              summary += `| Prettier | ${prettierStatus} |\n\n`;
              summary += `<!-- formatting-data: ${JSON.stringify(formattingData)} -->\n\n`;
            } else {
              summary += `‚è≥ *Pending...*\n\n`;
            }

            // Linting section
            summary += `### Linting\n`;
            if (lintingData) {
              const rustLintStatus = lintingData.rust_lint === 'success' ? '‚úÖ' : '‚ùå';
              const eslintStatus = lintingData.eslint === 'success' ? '‚úÖ' : '‚ùå';
              summary += `| Check | Status |\n`;
              summary += `|-------|--------|\n`;
              summary += `| Clippy | ${rustLintStatus} |\n`;
              summary += `| ESLint | ${eslintStatus} |\n\n`;
              summary += `<!-- linting-data: ${JSON.stringify(lintingData)} -->\n\n`;
            } else {
              summary += `‚è≥ *Pending or skipped (no code changes)...*\n\n`;
            }

            // Tests section
            summary += `### Tests\n`;
            if (testsData) {
              const formatResult = (result) => {
                if (result.total === 0) return { status: '‚ûñ', text: 'No tests' };
                const status = result.failures === 0 && result.errors === 0 ? '‚úÖ' : '‚ùå';
                return { status, text: `${result.passed}/${result.total} passed` };
              };

              const denoResult = formatResult(testsData.results.deno);
              const bunResult = formatResult(testsData.results.bun);
              const nodeResult = formatResult(testsData.results.node);
              const rustResult = formatResult(testsData.results.cargo);

              summary += `#### JavaScript Runtimes\n`;
              summary += `| Runtime | Status | Tests | Coverage |\n`;
              summary += `|---------|--------|-------|----------|\n`;
              summary += `| ü¶ï Deno | ${denoResult.status} | ${denoResult.text} | ${testsData.denoCoverage} |\n`;
              summary += `| ü•ü Bun | ${bunResult.status} | ${bunResult.text} | ${testsData.bunCoverage} |\n`;
              summary += `| üü¢ Node.js | ${nodeResult.status} | ${nodeResult.text} | ${testsData.nodeCoverage} |\n\n`;

              summary += `#### Rust Library\n`;
              summary += `| Component | Status | Tests | Coverage |\n`;
              summary += `|-----------|--------|-------|----------|\n`;
              summary += `| ü¶Ä Core | ${rustResult.status} | ${rustResult.text} | ${testsData.rustCoverage} |\n\n`;
              summary += `<!-- tests-data: ${JSON.stringify(testsData)} -->\n\n`;
            } else {
              summary += `‚è≥ *Pending or skipped (no code changes)...*\n\n`;
            }

            // Overall status
            const allComplete = formattingData && (lintingData || true) && (testsData || true);
            const allSuccess = (!formattingData || formattingData.success) &&
                              (!lintingData || lintingData.success) &&
                              (!testsData || testsData.success);

            if (formattingData || lintingData || testsData) {
              const overallStatus = allSuccess ? '‚úÖ All checks passing' : '‚ùå Some checks failed';
              summary += `**Overall Status**: ${overallStatus}\n\n`;
            }

            const timestamp = new Date().toISOString().replace('T', ' ').substring(0, 19);
            const runUrl = `https://github.com/${context.repo.owner}/${context.repo.repo}/actions/runs/${{ github.event.workflow_run.id }}`;
            summary += `*Last updated: ${timestamp} UTC | [View ${workflowName} Run](${runUrl})* ü§ñ`;

            // Create or update comment
            try {
              if (existingData.commentId) {
                await github.rest.issues.updateComment({
                  owner: context.repo.owner,
                  repo: context.repo.repo,
                  comment_id: existingData.commentId,
                  body: summary
                });
                console.log('Updated existing CI results comment');
              } else {
                await github.rest.issues.createComment({
                  owner: context.repo.owner,
                  repo: context.repo.repo,
                  issue_number: prNumber,
                  body: summary
                });
                console.log('Created new CI results comment');
              }
            } catch (error) {
              console.error('Error managing comment:', error);
            }

      # Create status check for the workflow that triggered this run
      - name: Create status check
        if: steps.pr-info.outputs.result && fromJSON(steps.pr-info.outputs.result).prNumber
        uses: actions/github-script@v8
        with:
          script: |
            const fs = require('fs');
            const success = ${{ fromJSON(steps.pr-info.outputs.result).success }};
            const conclusion = '${{ fromJSON(steps.pr-info.outputs.result).conclusion }}';
            const headSha = '${{ fromJSON(steps.pr-info.outputs.result).headSha }}';
            const workflowName = '${{ fromJSON(steps.pr-info.outputs.result).workflowName }}';

            let state = success ? 'success' : 'failure';
            let description = success ? `${workflowName} passed` : `${workflowName} ${conclusion}`;
            let contextName = workflowName;

            // For specific workflows, provide more detailed status
            if (workflowName === 'Formatting') {
              try {
                const resultsPath = 'formatting-results/results.json';
                if (fs.existsSync(resultsPath)) {
                  const content = fs.readFileSync(resultsPath, 'utf8');
                  const results = JSON.parse(content);
                  const failedChecks = [];
                  if (results.rust_fmt === 'failure') failedChecks.push('Rust fmt');
                  if (results.prettier_fmt === 'failure') failedChecks.push('Prettier');
                  if (failedChecks.length > 0) {
                    state = 'failure';
                    description = `Failed: ${failedChecks.join(', ')}`;
                  }
                }
              } catch (error) {
                console.log('Could not read formatting results:', error.message);
              }
            }

            if (workflowName === 'Linting') {
              try {
                const resultsPath = 'linting-results/results.json';
                if (fs.existsSync(resultsPath)) {
                  const content = fs.readFileSync(resultsPath, 'utf8');
                  const results = JSON.parse(content);
                  const failedChecks = [];
                  if (results.rust_lint === 'failure') failedChecks.push('Clippy');
                  if (results.eslint === 'failure') failedChecks.push('ESLint');
                  if (failedChecks.length > 0) {
                    state = 'failure';
                    description = `Failed: ${failedChecks.join(', ')}`;
                  }
                }
              } catch (error) {
                console.log('Could not read linting results:', error.message);
              }
            }

            try {
              await github.rest.repos.createCommitStatus({
                owner: context.repo.owner,
                repo: context.repo.repo,
                sha: headSha,
                state: state,
                target_url: `https://github.com/${context.repo.owner}/${context.repo.repo}/actions/runs/${{ github.event.workflow_run.id }}`,
                description: description.substring(0, 140),
                context: contextName
              });
              console.log(`Status check created: ${contextName} - ${state} - ${description}`);
            } catch (error) {
              console.error('Failed to create status check:', error);
            }
